apply plugin: 'mxjava';

import groovyx.gpars.GParsPool
import net.masterthought.cucumber.ReportBuilder
import net.masterthought.cucumber.Configuration
import net.masterthought.cucumber.Reportable

dependencies {
   compile project(":am-web-driver");
   compile project(":mxapispec");
   compile "junit:junit:${junitVersion}";
   compile "com.fasterxml.jackson.core:jackson-core:${jacksonVersion}"
   compile "com.fasterxml.jackson.core:jackson-databind:${jacksonVersion}"
   compile "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider:${jacksonVersion}"

   // Web Driver Factory
   compile "com.mxi.driver:web-driver-factory:${driverVersion}";
   runtime files( weblogicOjdbcJar );

   // ppc
   compile project(":ppc");
   compile project(":ppcthickclient:ppcthickclient");
   compile project(":ppcthickclient:ppcmodel");
   compile "com.mxi.driver:swing-driver:${SwingDriverVersion}"
   compile "ilog.jviews:jviews-chart:${jviewsVersion}"
   compile "ilog.jviews:jviews-framework:${jviewsVersion}"
   compile "ilog.jviews:jviews-gantt:${jviewsVersion}"

   // Work package loader
   compile project(":wpl-client");

   // Api Driver Factory
   compile "com.mxi.driver:api-driver:${driverVersion}";
   compile project(":mxcoreapi");
   compile project(":integrationclient");

   compile "com.mxi.mx.api:apicommon:${apiVersion}";

   compile "com.mxi.xml:mxxml:${mxxmlVersion}"

   // Cucumber
   compile "info.cukes:cucumber-junit:1.2.4";
   compile "info.cukes:cucumber-java:1.2.4";
   compile "info.cukes:cucumber-guice:1.2.4";
   compile "com.google.inject:guice:${guiceVersion}";

   compile "io.rest-assured:rest-assured:${restAssuredVersion}"
   compile "io.rest-assured:json-path:${restAssuredVersion}"

   // Selenium test utility
   compile "com.mxi.testutil:testutils-selenium:0.1.0.0";
}

buildscript {
    dependencies {
        classpath "com.avast.gradle:gradle-docker-compose-plugin:0.6.0"
    }
}

apply plugin: 'docker-compose'

// Dynamic jasper URL
def jasperURL = "${artifactoryRepoUrl}/mx-release-libs/com.mxi.jaspersoft/${jaspersoftVersion}/jaspersoft-server/tar/maintenix-reports-server-${jaspersoftVersion.replace(".","")}.tar.gz"

// grabs only the first 2 version levels from the driver version, for matching with the correct compose file
def majorDriverVersion = "${driverVersion}".substring(0,3);

dockerCompose {
      forceRecreate = true
      waitForTcpPorts = false
      // specifies compose files depending on browser preference
      if (testBrowser.contains("chrome") && (testBrowser.contains("docker"))) {
        smokeTest {
          useComposeFiles = ["src/main/resources/${majorDriverVersion}/docker-compose-smokeTest-chrome.yaml"]
        }
        envTest {
           useComposeFiles = ["src/main/resources/${majorDriverVersion}/docker-compose-envTest-chrome.yaml"]
        }
      } else if (testBrowser.contains("firefox") && (testBrowser.contains("docker"))) {
        smokeTest {
           useComposeFiles = ["src/main/resources/${majorDriverVersion}/docker-compose-smokeTest-firefox.yaml"]
        }
        envTest {
           useComposeFiles = ["src/main/resources/${majorDriverVersion}/docker-compose-envTest-firefox.yaml"]
        }
      }
      jasper {
      	useComposeFiles = ['src/main/resources/docker-compose-jasper.yaml']
        // variables below passed into context of jasper server container
        environment.put 'JASPER_DB_HOST', InetAddress.localHost.hostName
        environment.put 'JASPER_DB_ORACLE_PORT', 1522
        environment.put 'JASPER_DB_ORACLE_SID', e2eJasperDbSid
        environment.put 'JASPER_DB_USERNAME', e2eJasperDbUsername
        environment.put 'JASPER_DB_PASSWORD', e2eJasperDbPassword
        environment.put 'MAINTENIX_HOST', InetAddress.localHost.hostName
        environment.put 'MAINTENIX_PORT', 80
        environment.put 'JASPERSOFT_VERSION', jaspersoftVersion
      }
      
   }

// Enviroments
apply plugin: 'mxenvironment';
configurations {
   license
   installer
   virtualEar
   liquibase
   database {
      transitive = false;
      extendsFrom liquibase
   }
   jaspersoftInstaller
}

dependencies {
   license project(":mxcommon:mxcommonutils");
   license "com.mxi.xml:mxxml:${mxxmlVersion}"
   license project(":mxversion");
   installer project(path: ":assetmanagement-installer", configuration: "windows");
   jaspersoftInstaller project(path: ":assetmanagement-jaspersoft-installer", configuration: "windows");
   virtualEar "com.mxi.weblogic:weblogic-devtools:${weblogicUtilsVersion}";
   database project(path: ":assetmanagement-database", configuration: 'database');
   liquibaseDeployer "com.mxi.idk:database-deployer-cli:${idkVersion}";
   liquibase "com.mxi.idk:dbtools-db:${idkVersion}";
}

configurations { loader }

dependencies {
   loader "com.mxi.dataloader:dataloader:${dataloaderVersion}";
   loader "com.mxi.dataloader:csvloader:${dataloaderVersion}";
   loader "com.mxi.dataloader:sqlloader:${dataloaderVersion}";
   loader project(":assetmanagement-data-loader");
}

environments {
   e2e {
      database {
         if (useDocker.toBoolean()){
            // The following properties must be configured to use the database in the Docker container.
            // Set user and password to mx_user if you want this environment to use the pre-created database user in the Docker image.
            // Assign unique ports to prevent collisions with other Docker containers.
            // The recommended port for the DB Control utility is the 11xx version of the database port to make it easy to find.
            host="localhost";
            password="mx_user";
            username="mx_user";
            port=1522;
            def dbControlPort=1122;
            service="or11g";
            recreateDatabaseUser=false;

            docker {
               cleanup = "docker container rm -f ${productLabelPrefix}${productLabelCodeName}_${name}_db";
               pull = "docker image pull ${dockerBaseImage}";
               run = "docker container run --detach --name ${productLabelPrefix}${productLabelCodeName}_${name}_db --publish ${port}:1521 --publish ${dbControlPort}:1158 --tmpfs /dev/shm:rw,exec,suid ${dockerBaseImage}";
             }
         }
         install {
            if (useDocker.toBoolean()){
               liquibase {
                  configuration = configurations.database;
               }
               assertComponentVersion {
                 componentCd = 'assetmanagement-database';
                 major = Integer.valueOf(projectMajorVersion);
                 minor = Integer.valueOf(projectMinorVersion);
                 servicepack = Integer.valueOf(projectServicepackVersion);
                 update = Integer.valueOf(projectUpdateVersion);
               }
            }
            else {
               plsqlExec {
                  workingDirectory = file("${rootProject.projectDir}\\assetmanagement-database\\src\\base\\plsql");
                  controlFile = file("${workingDirectory}\\control.sql");
               }
               setupMaintenixAudit {
               }
               version {
                  componentName = "Maintenix";
                  moduleName = "Maintenix.Schema";
                  major = Integer.valueOf(productMajorVersion);
                  minor = Integer.valueOf(productMinorVersion);
                  servicepack = Integer.valueOf(productServicepackVersion);
                  update = Integer.valueOf(productUpdateVersion);
               }
               liquibase {
                         configuration = configurations.database;
               }
               componentVersion {
                  componentCd = 'assetmanagement-database';
                  major = Integer.valueOf(projectMajorVersion);
                  minor = Integer.valueOf(projectMinorVersion);
                  servicepack = Integer.valueOf(projectServicepackVersion);
                  update = Integer.valueOf(projectUpdateVersion);
               }
            }
            plsqlExec {
               workingDirectory = file("${rootProject.projectDir}\\assetmanagement-database\\src\\solution\\plsql");
               controlFile = file("${workingDirectory}\\control.sql");
            }
            load {
               loaderConfiguration = configurations.loader;
               dataDir = file("src\\main\\data");
            }

         }

         upgrade {
            componentVersion {
               componentCd = 'assetmanagement-database';
               major = Integer.valueOf(previousMajorVersion);
               minor = Integer.valueOf(previousMinorVersion);
               servicepack = Integer.valueOf(previousServicepackVersion);
               update = Integer.valueOf(previousUpdateVersion);
            }
            liquibase {
               configuration = configurations.database;
            }
            assertComponentVersion {
               componentCd = 'assetmanagement-database';
               major = Integer.valueOf(projectMajorVersion);
               minor = Integer.valueOf(projectMinorVersion);
               servicepack = Integer.valueOf(projectServicepackVersion);
               update = Integer.valueOf(projectUpdateVersion);
            }
            load {
                loaderConfiguration = configurations.loader;
                dataDir = file("src\\main\\upgrade");
             }
         }
      }

      application {
         installerConfiguration = configurations.installer;
         developmentMode = true;

         license {
            licenseConfiguration = configurations.license;
            unsignedLicenseFile = file("weblogic-license.xml");
            version = maintenixVersionNumber;
         }

         webLogic {
            domainDir = file("${installDir}/domain");
            adminHttpPort = Integer.valueOf( project.adminHttpPort );
            appHttpPort = Integer.valueOf( project.appHttpPort );
         }

         settings = [
            "initial.heap.size": initialHeapSize,
            "maximum.heap.size": maximumHeapSize,
            "oracle.home": oracleHome,
            "mail.host": mailHost,
            "mail.system.address": mailSystemAddress,
            "admin.username": adminUsername,
            "admin.password": adminPassword,
            "admin.https.port": adminHttpsPort,
            "admin.http.port": webLogic.adminHttpPort,
            "app.http.port": webLogic.appHttpPort,
            "app.https.port": appHttpsPort,
            "startup.service.install": false,
            "startup.service.name": startupServiceName,
            "startup.service.user": startupServiceUser,
            "node.manager.service.install": false,
            "node.manager.service.name": nodeManagerServiceName,
            "node.manager.service.user": nodeManagerServiceUser,
            "node.manager.listen.port": nodeManagerListenPort,
            "node.manager.enable.crash.recovery": nodeManagerEnableCrashRecovery,
            "datasource.username": database.username,
            "datasource.password": database.password,
            "datasource.host": database.host,
            "datasource.port": database.port,
            "datasource.service": database.service,
            "jaspersoft.configure": jaspersoftConfigure,
            "jaspersoft.host": jaspersoftHost,
            "jaspersoft.port": jaspersoftPort,
            "jaspersoft.username": jaspersoftUsername,
            "jaspersoft.password": jaspersoftPassword,
            "log4j": "${projectDir}/weblogic-log4j.xml",
            "license.key": "${license.publicKey}",
            "license.path": "${license.signedLicenseFile}",
            "domain.home": webLogic.domainDir.toString(),
            "app.home": "${installDir}/apps",
            "data.home": "${installDir}/data",
            "java.home": "${installDir}/java",
            "ssl.identity.keystore.password": "${identityKeyStorePassword}",
            "ssl.identity.keystore.type": "${identityKeyStoreType}",
            "ssl.trust.keystore.password": "${trustKeyStorePassword}",
            "ssl.trust.keystore.type": "${trustKeyStoreType}",
            "ssl.server.key.password": "${serveyKeyPassword}"
         ];

         virtualEar {
            virtualEarConfiguration = configurations.virtualEar;
            earFile = file("${installDir}/apps/assetmanagement/app/assetmanagement.ear");
            dcevmLibrary = file("${sharedResourceDir}/dcevm/${dcevmVersion}")
         }

         sso {
            appHttpsPort = Integer.valueOf( project.appHttpsPort );
            idpEntityId = project.idpEntityId;
            resourceConfigDir = file("${installDir}/apps/assetmanagement/resource/config");
         }
      }     
      if (jasperDocker.toBoolean()){
         jaspersoft {
            installerConfiguration = configurations.jaspersoftInstaller
            dataSourceUsername="mx_user";
            dataSourcePassword="mx_user";
            dataSourceHost= InetAddress.getLocalHost().getHostName();
            dataSourcePort=1522;
            dataSourceService="or11g";
            jaspersoftConfigure= true;
            jaspersoftHost = e2eJasperHost;
            jaspersoftPort = Integer.valueOf(e2eJasperPort);
            jaspersoftUsername = e2eJasperUsername;
            jaspersoftPassword = e2eJasperPassword;
         }
      }
   }  
}

// Copying scripts required for setting up jasper db to e2e database container
task copyJasperResources (type:Exec){

  // copy database setup shell script from resources to container
  commandLine 'docker', 'cp', 'src/main/resources/jasper/import_jasper_db.sh', "${productLabelPrefix}${productLabelCodeName}_e2e_db:/"
}

// Running scripts for setting up jasper db
task setupJasperDatabase (type:Exec){
  dependsOn copyJasperResources;
 
  // docker exec database import shell script
  // Note: database port is 1521 since it's running from inside db container
  commandLine 'docker', 'exec', '-u','0','-i', "${productLabelPrefix}${productLabelCodeName}_e2e_db", '\"./import_jasper_db.sh\"', "${jasperURL}", "${e2eJasperDbUsername}", "${e2eJasperDbPassword}", "${e2eJasperDbHost}", "${e2eJasperDbPort}", "${e2eJasperDbSid}";
}

createE2eDb.dependsOn configurations.database;
upgradeE2eDb.dependsOn configurations.database;

// adds jasper database after the e2e database has been setup
if (jasperDocker.toBoolean()){
  createE2eDb.finalizedBy setupJasperDatabase;
  copyJasperResources.mustRunAfter createE2eDb;
}

// Put database.properties into source
task updateDatabaseProperties {
   ext.propertiesFile = file("src/main/resources/database.properties");

   inputs.property 'host', environments.e2e.database.host;
   inputs.property 'port', environments.e2e.database.port;
   inputs.property 'service', environments.e2e.database.service;
   inputs.property 'username', environments.e2e.database.username;
   inputs.property 'password', environments.e2e.database.password;
   outputs.file ext.propertiesFile;

   doFirst {
      Properties lProperties = new Properties();
      lProperties.setProperty("database.host", environments.e2e.database.host);
      lProperties.setProperty("database.port", String.valueOf(environments.e2e.database.port));
      lProperties.setProperty("database.service", environments.e2e.database.service);
      lProperties.setProperty("database.username", environments.e2e.database.username);
      lProperties.setProperty("database.password", environments.e2e.database.password);

      lProperties.store(ext.propertiesFile.newWriter(), null);
   }
}

processResources { dependsOn updateDatabaseProperties; }

// update jasper properties for mx-jasper connection
task updateJasperProperties {
   ext.propertiesFile = file("build/environment/e2e/apps/assetmanagement/resource/property/jasperreportengine.properties");

   inputs.property 'report.host', e2eJasperHost;
   inputs.property 'report.port', e2eJasperPort;
   inputs.property 'login.username', e2eJasperUsername;
   inputs.property 'encrypted.login.password', e2eJasperPassword;
   inputs.property 'report.usehttps', "false";
   inputs.property 'client.postdelay', "1";
   inputs.property 'client.maxretries', "7200";
   outputs.file ext.propertiesFile;

   doFirst {
      Properties lProperties = new Properties();
      lProperties.setProperty("report.host", e2eJasperHost);
      lProperties.setProperty("report.port", String.valueOf(e2eJasperPort));
      lProperties.setProperty("login.username", e2eJasperUsername);
      lProperties.setProperty("encrypted.login.password", e2eJasperPassword);
      lProperties.setProperty("report.usehttps", "false");
      lProperties.setProperty("client.postdelay", "1");
      lProperties.setProperty("client.maxretries", "7200");

      lProperties.store(ext.propertiesFile.newWriter(), null);

      println "Updated jasper properties";
   }
}

// jasper properties file must be updated after the app server has been installed, but before the server starts
if (jasperDocker.toBoolean()){
   installE2eApp.finalizedBy updateJasperProperties;
   startE2eEnv.mustRunAfter updateJasperProperties;
}

// map of e2e test runners with test name and include filter
def testList = ['env':'**/RunAllCucumberTests.class', 'anno':'**/RunAnnotatedCucumberTests.class', 'ppc':'**/RunPPCCucumberTests.class']

// dynamically generates e2e test runners
testList.each { test, resource ->
  task("${test}Test", type: Test) {

    // setup test memory requirements
    minHeapSize = "${testMinHeapSize}"
    maxHeapSize = "${testMaxHeapSize}"

    include resource;
    include '**/com/mxi/mx/api/**/*Test.class';
    include '**/com/mxi/am/api/**/*Test.class';

    testClassesDirs = sourceSets.main.output.classesDirs;

    // Set webdriver.browser as system property
    systemProperty "webdriver.browser", System.getProperty("webdriver.browser")

    if ( systemProperties['webdriver.browser'] == null ) {
      systemProperty "webdriver.browser", "${testBrowser}"
    }

  }
}

// Runs API smoke tests
task runAPITests(type: Test) {
    dependsOn this.classes;
    // setup test memory requirements
    minHeapSize = "${testMinHeapSize}"
    maxHeapSize = "${testMaxHeapSize}"

    include '**/com/mxi/mx/api/**/*Test.class';
    include '**/com/mxi/am/api/**/*Test.class';
    include '**/com/mxi/web/followonreqdefn/api/**/*Test.class';

    testClassesDirs = sourceSets.main.output.classesDirs;
}

// calls docker compose up if specified
if (testBrowser.contains('docker')) {
   envTest.dependsOn 'envTestComposeUp';
}


// Runs unique config e2e tests in sequence
def runUniqueConfigTestsInSequence() {
    
   def arglist = [
      "-p", "json:build/reports/cucumber/uniqueconfig/uniqueconfig.json",
      "-p", "junit:build/test-results/envTest/uniqueconfig/cucumber.xml",
      "--glue", "com.mxi.am.stepdefn",
      "src/main/resources/com/mxi/am/uniqueconfig",
      "--tags", "@UniqueConfigSmokeTest",
      "--tags", "~@Ignore"]

   return javaexec {
      main = "cucumber.api.cli.Main"
      classpath = files(createManifest.archivePath, sourceSets.main.output);
      args = arglist
      maxHeapSize = "${testMaxHeapSize}"
      systemProperty "webdriver.browser", "${testBrowser}"
      ignoreExitValue = true
   }    
}



task createManifest (type: Jar) {
  manifest {
      attributes(
            "Class-Path": sourceSets.main.runtimeClasspath.files.collect{ project.uri(it) }.join(' ')
      )
   }
}

// Runs e2e tests with tag filter in parallel
def runTestsInParallel(tag) {
   def features = fileTree(dir: "src/main/resources/com/mxi/am/").include '**/*.feature';

   GParsPool.withPool("${e2eThreads}".toInteger()) {
      features.eachParallel { File file ->

         def arglist = [
            "-p", "json:build/reports/cucumber/${file.name}.json",
            "-p", "junit:build/test-results/envTest/${file.name.take(file.name.lastIndexOf('.'))}.xml",
            "--glue", "com.mxi.am.stepdefn",
            "${file.absolutePath}",
            "--tags", "${tag}",
            "--tags", "~@Ignore"]

         javaexec {
            main = "cucumber.api.cli.Main"
            classpath = files(createManifest.archivePath, sourceSets.main.output);
            args = arglist
            maxHeapSize = "${testMaxHeapSize}"
            systemProperty "webdriver.browser", "${testBrowser}"
            ignoreExitValue = true
         }
      }
   }
}

// creates cucumber feature test report by combining all JSON test results
def generateTestReport(isParallel) {
    def jsonReports = fileTree(dir: "build/reports/cucumber/").include '**/*.json'.toString();
    File reportOutputDirectory = file("build/reports/cucumber");

    def jsonReportFiles = [];
    jsonReports.each { File file ->
        jsonReportFiles.add("${file.path}".toString());
    }

    Configuration configuration = new Configuration(reportOutputDirectory, 'cucumber-gradle-parallel');
    // optional configuration
    configuration.setParallelTesting("${isParallel}".toBoolean());
    configuration.setRunWithJenkins(false);
    configuration.addClassifications("Browser", "${testBrowser}");
    configuration.addClassifications("Driver Version", "${driverVersion}");


    ReportBuilder reportBuilder = new ReportBuilder(jsonReportFiles, configuration);
    Reportable result = reportBuilder.generateReports();
    println("\nReport available on: build/reports/cucumber/cucumber-html-reports/overview-features.html");
}


// runs all e2e smoke tests
task runE2ESmoke {
   dependsOn this.classes;
   dependsOn createManifest;

   doLast{
      runTestsInParallel("@E2ESmokeBuild1,@JspSmokeTest");
      runUniqueConfigTestsInSequence();
   }
}

// calls docker compose up if specified
if (testBrowser.contains('docker')) {
   runE2ESmoke.dependsOn 'smokeTestComposeUp';

}

// starts Jasper server if specified
if (jasperDocker.toBoolean()){
   runE2ESmoke.dependsOn 'startJasper';
}

// generates cucumber report - parallel mode
task generateParallelReport {
   doLast {
       generateTestReport("true")
   }
}

// calls docker compose down if specified
if (testBrowser.contains('docker')) {
   generateParallelReport.dependsOn 'smokeTestComposeDown';
}

// stops Jasper server if it is used
if (jasperDocker.toBoolean()){
   generateParallelReport.dependsOn 'stopJasper';
}

// generates cucumber report - sequence mode
task generateSequenceReport {
   doLast {
       generateTestReport("false")
   }
}

// calls docker compose down if specified
if (testBrowser.contains('docker')) {
   generateSequenceReport.dependsOn 'envTestComposeDown';
}

// calls appropriate report generator task based on build
runE2ESmoke.finalizedBy generateParallelReport;
envTest.finalizedBy generateSequenceReport;
annoTest.finalizedBy generateSequenceReport;
ppcTest.finalizedBy generateSequenceReport;

// calls docker compose down if specified
task smokeSetUp (){
   dependsOn envSetUp;
}

// ** main gradle target task for e2e smoke build **
// runs all e2e smoke tests and API tests
task smokeTest (){
   dependsOn runE2ESmoke;
   dependsOn runAPITests;
}

// specifies task order dependencies
runE2ESmoke.mustRunAfter(smokeSetUp);
runAPITests.mustRunAfter(runE2ESmoke);

task smokeTeardown (){
   dependsOn envTearDown;
}

if (jasperDocker.toBoolean()){
   installE2eJaspersoft.dependsOn 'jasperComposeUp';

   task startJasper (){
      dependsOn installE2eJaspersoft;
   }

   task stopJasper (){
      dependsOn 'jasperComposeDown';
   }
}

javadoc.enabled = false;


configurations {
   buildinfoproperties
}

dependencies {
   buildinfoproperties project( path: ':installers:buildinfo', configuration: 'buildinfoproperties' )
}

zipEnvTestResults {
   dependsOn configurations.buildinfoproperties
   from( configurations.buildinfoproperties )
   from( fileTree( 'build' ) ) { include 'reports/cucumber*/**/*' }
}

task zipSmokeTestResults(type: Zip) {
   dependsOn configurations.buildinfoproperties
   version = ''
   destinationDir = file( 'build/zipped-test-results' )
   from( fileTree( 'build' ) ) { include 'reports/tests/**/*', 'reports/cucumber*/**/*', 'test-results/**/*' }
   from( configurations.buildinfoproperties )
}

runAPITests.finalizedBy zipSmokeTestResults, deployTestResults
runE2ESmoke.finalizedBy zipSmokeTestResults, deployTestResults
envTest.finalizedBy zipEnvTestResults, deployTestResults
stopE2eEnv.finalizedBy zipE2eServerLogs, deployTestResults

zipEnvTestResults.mustRunAfter generateSequenceReport, generateParallelReport
zipSmokeTestResults.mustRunAfter generateSequenceReport, generateParallelReport

deployTestResults {
   mustRunAfter zipSmokeTestResults
   organisation = "${projectGroup}.envtest"
   deploy( zipEnvTestResults, project.name, 'envtest', 'envtest' )
   deploy( zipSmokeTestResults, project.name, 'smoke', 'smoke' )
}

// Publishing to Ivy
publishing.publications {
   ivy(IvyPublication) {
      from components.java

      configurations {
         create "am-e2e-test"
         create "sources"
      }

      artifact(sourceJar) {
         type "source"
         conf "sources"
      }
   }
}
